package main

import (
	"errors"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/maxzerbini/oauth"
)

//registerAPI gives an API for authentication Page
func registerAPI(router *gin.Engine) {
	s := oauth.NewOAuthBearerServer(
		secret,
		time.Hour*600,
		&TestUserVerifier{},
		nil)
	router.POST("/auth", s.ClientCredentials)
	router.POST("/token", s.ClientCredentials)
}

// ValidateUser validates username and password returning an error if the user credentials are wrong
func (*TestUserVerifier) ValidateUser(username, password, scope string, req *http.Request) error {
	return errors.New("Wrong user")
}

// ValidateClient validates clientId and secret returning an error if the client credentials are wrong
func (*TestUserVerifier) ValidateClient(clientID, clientSecret, scope string, req *http.Request) error {
	var oAuthType string
	var oAuthID string
	clientsecret = clientSecret
	db = CreateDBConnection()
	defer db.Close()
	if clientID != "Apple" && clientID != "Google" && clientID != "Microsoft" {
		return errors.New("Wrong client")
	}
	stmtUserOut, err := db.Prepare("Select oAuthType, oAuthID from user where oAuthID = ?")
	if err != nil {
		return errors.New("Failed to prepare select statement")
	}
	stmtUserOut.QueryRow(clientSecret).Scan(&oAuthType, &oAuthID)
	if oAuthType == "" {
		stmtUserCreate, err := db.Prepare("Insert into user (oAuthType,oAuthID) VALUES (?,?)")
		if err != nil {
			return errors.New("Failed to prepare sql statement")
		}
		_, err = stmtUserCreate.Exec(clientID, clientSecret)
		if err != nil {
			return errors.New("Failed to create new user")
		}
		return nil
	} else if clientID == oAuthType && clientSecret == oAuthID {
		return nil
	}
	return errors.New("Wrong client")
}

// AddClaims provides additional claims to the token
func (*TestUserVerifier) AddClaims(credential, tokenID, tokenType, scope string) (map[string]string, error) {
	claims := make(map[string]string)
	claims["oAuthID"] = clientsecret
	return claims, nil
}

// StoreTokenId saves the token Id generated for the user
func (*TestUserVerifier) StoreTokenId(credential, tokenId, refreshTokenID, tokenType string) error {
	db = CreateDBConnection()
	defer db.Close()
	stmtUserUpdate, err := db.Prepare("update user set tokenid = ? where oAuthID = ?")
	if err != nil {
		return errors.New("Failed to create new user")
	}
	_, err = stmtUserUpdate.Exec(tokenId, clientsecret)
	if err != nil {
		return errors.New("Failed to create new user")
	}
	return nil
}

// AddProperties provides additional information to the token response
func (*TestUserVerifier) AddProperties(credential, tokenId, tokenType string, scope string) (map[string]string, error) {
	var username, email, image, _, err = GetUserInformation(clientsecret)
	if err != nil {
		return nil, errors.New("Failed to get User properties")
	}
	props := make(map[string]string)
	props["email"] = email
	props["oAuthType"] = credential
	props["oAuthID"] = clientsecret
	props["username"] = username
	props["image"] = image
	return props, nil
}

// ValidateTokenId validates token Id
func (*TestUserVerifier) ValidateTokenId(credential, tokenId, refreshTokenID, tokenType string) error {
	if tokenid == tokenId {
		return nil
	}
	return errors.New("Failed to store Token")
}

// ValidateCode validates token Id
func (*TestUserVerifier) ValidateCode(clientID, clientSecret, code, redirectURI string, req *http.Request) (string, error) {
	return "", nil
}
